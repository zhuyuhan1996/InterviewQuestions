**内核线程：**由操作系统内核创建和撤销，内核空间实现还为每个内核支持线程设置了一个线程控制块，内核是根据该控制块而感知某个线程是否存在，并加以控制。线程切换也由内核控制，切换的时候，要从用户态进入内核态，切换完毕要从内核态返回用户态。可以很好的利用多 CPU

**用户级线程：**仅存在于用户空间中。线程的创建、撤销、线程之间的同步和通信等功能，都无需系统调用来实现。对于同一进程的线程之间切换仍然是不需要内核支持的。因此，内核也不知道用户级线程的存在，少了进出内核态的消耗，但不能很好的利用多 CPU。

**用户线程的优点：**

可以在不支持线程的操作系统中实现。

创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程。

允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别。

线程能够利用的表空间和堆栈空间比内核级线程多。

不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷。

线程的调度不需要内核直接参与，控制简单。

**用户线程的缺点：**

线程发生 I/O 或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行。

页面失效也会产生类似的问题。

一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程。

资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用。

**内核线程的优点:**

多处理器系统中，内核能够并行执行同一进程内的多个线程。

如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）。

所有能够阻塞线程的调用都以系统调用的形式实现，代价可观。

当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程。

信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号。