RAII是资源分配：定义一个类来封装资源的分配和释放，在构造函数完成资源的分配，在析构函数完成资源的释放。

所谓智能指针就是智能、自动化的管理指针所指向的动态资源的释放。它是一个类，有类似指针的功能。

当类中有指针成员时，一般有两种方式管理指针成员：

采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；

另一种方式就是采用智能指针，从而实现指针指向的对象的共享。

将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象的指针指向同一对象。每次创建类的新对象时。初始化指针就将引用计数置为1；当对象作为另一对象的副本创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数，并增加右对象的引用计数；调用析构函数时，析构函数减少引用计数。常见的智能指针有：auto_ptr，shared_ptr,weak_ptr.

第一种实现：auto_ptr 独占所有权，转移所有权

不能以值传递的方式进行传递的。

在构造对象时赋予管理空间的所有权，在拷贝或赋值中转移空间的所有权。当析构函数中_owner为true时来释放所有权。

问题：如果拷贝出来的对象比原来的对象先出作用域或先调用析构函数。则原来的对象的_owner虽然为false，但是却在访问一块已经释放的空间，原因在于拷贝对象的释放会导致原对象的-ptr指向的内容也跟着释放。

shared_ptr 共享所有权，引用计数。

实现原理是通过引用计数实现的，拷贝或者赋值时将引用计数加1，析构时只有当引用计数减到0才释放空间，否则只需要将引用计数减1即可。（在C++11中叫做unique_ptr）

问题：在多线程环境下，引用计数的更新存在安全隐患（可以增加一把互斥锁）；循环引用问题；定制删除器。

循环引用的问题可以采用（弱引用指针），对引用计数做特殊处理。