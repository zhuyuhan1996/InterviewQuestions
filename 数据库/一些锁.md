**互斥锁：**

互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性

**自旋锁：**

采用让当前线程不停的在循环体内执行实现，当循环的条件被其它线程改变时才能进入临界区。

一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。

由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。

**阻塞锁：**

阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态。

阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致 CPu占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。在竞争激烈的情况下 阻塞锁的性能要明显高于自旋锁。

**可重入锁：**

Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。

可重入锁的最大优点就是可以避免死锁。缺点是必须手动开启和释放锁

因为写者和写者为互斥关系，因此一定要加上互斥锁；而读者和读者之间并不需要互斥，读写锁的高效就是多个读者可以在同一时间段从缓冲区中取出数据，因此，要想维持读者和写者之间的互斥关系，就可以加入条件变量，当读者的条件不满足时，也就是写者在向缓冲区中写入数据的时候，读者就要等待挂起，为了使读者在读取数据的时候写者不往缓冲区写数据，可以让写者sleep1秒，也就是保证读者再一次进入wait等待的时候写者才获得互斥锁进行缓冲区的操作。